# lab2 Challenge3

**扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）**

> - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？

## 一 . 解决方法

如果OS无法提前知道当前硬件的可用物理内存范围，那么可以从以下角度去思考解决方案：

1. **操作系统自行探测内存**。操作系统自身可以通过运行一段特殊的代码或使用特殊的工具，以此来达到检测可用物理内存范围的目的。例如：
   - **迭代分配物理内存**。操作系统从起始地址开始一直向后分配内存，如果分配成功，则将其加入到可用物理内存范围中；如果分配失败，则说明已经到达物理内存上限。当达到物理内存上限后，逐步缩小分配的内存大小，最后便能确定可用物理内存范围；
   - **系统启动时进行内存探测**。操作系统在启动之前会有**bootloader**程序和预处理程序执行，这些程序的执行会对物理内存进行访问，操作系统可以通过这些程序对物理内存进行范围的大致探测；
   - **使用Opensbi固件接口**。Opensbi中拥有获取物理内存范围信息的接口`platform_memory_region`，此接口可以通过调用`platform.memory_region`函数来访问。最后会返回一个包含物理内存范围信息的结构体数组，每个元素对应**一个物理内存区域**的**起始地址**和**大小**。操作系统通过解析这些信息最终便可以成功获取可用的物理内存范围；
   - **使用系统管理工具**。操作系统提供的一些系统管理工具，可以显示当前系统的内存使用情况，包括可用内存和已用内存的数量。通过分析可用内存和已用内存便可以分析出可用物理内存范围。
2. **与硬件交互**。操作系统通过内存驱动管理程序来与硬件进行交互，从而可以读取硬件内存条上的信息，通过分析这些信息也可以对可用物理内存范围进行获取；

## 二  . linux中获取可用物理内存范围的方法

> linux中获取内存容量的方法有很多，共性是调用**BIOS中断的0x15**实现的，分别是**0x15**的三个子功能，子功能号存放在寄存器**EAX**或者**AX**中。BIOS中断可以返回已安装的硬件信息，它获取硬件信息也需要依靠硬件提供的接口。每次中断发生后，通过连续调用硬件的API便可以获取足够的内存信息。

---



**中断0x15的三个子功能分别为：**

1. **子功能0xe820；**
2. **子功能0xe801；**
3. **子功能0x88；**

这三个子功能中从**0xe820**到**0x88**能够查询的物理内存范围越来越小，功能越来越弱。linux中对三个子功能的调用是安装功能从强到弱的顺序来调用的，当一种子功能查询失败时才会依次调用下一种子功能。

下面我们对功能最强的中断0x15的子功能0xe820进行介绍。

---



### 对中断0x15的子功能0xe820的介绍：

此子功能返回的内存信息较丰富，包含多个属性字段，并且由地址范围描述符**(ARDS)**来组织这些数据。地址范围描述符结构如下：

| 字节偏移量 | 属性名称     | 描述             |
| ---------- | ------------ | ---------------- |
| 0          | BaseAddrLow  | 基地址的低32位   |
| 4          | BaseAddrHigh | 基地址的高32位   |
| 8          | LengthLow    | 内存长度的低32位 |
| 12         | LengthHigh   | 内存长度的高32位 |
| 16         | Type         | 本段内存的类型   |

此结构中五个属性字段全为4个字节大小，一共占20个字节大小。每次执行这个中断就会返回这样一个**ARDS**。**Type**字段为1表示这段内存可以被操作系统使用，为2则表示内存使用中或者被系统保留，操作系统不可以用此内存。

显然，我们根据Type字段以及基地址和内存长度便确定出了一片物理内存区域，并且还可以知道其可用不可用。



**BIOS中断是一段函数例程**，调用BIOS中断便需要**设置参数**，并将参数保存在寄存器中，对于BIOS中断0x15的0xe820来说，它所需要的参数及保存的寄存器如下：

1. **EAX**：存放子功能号，即**0xe820**；
2. **EBX**：ARDS后续值，主要作业是告诉中断下一次调用时返回哪个**ARDS**，第一次置**0**，后面不再需要关注；
3. **ES:DI**：ARDS缓冲区。每次中断后返回的**ARDS**写入此寄存器指向的内存；
4. **ECX**：ARDS结构的字节大小，即**20**；
5. **EDX**： 固定为签名，标记为**0x534d4150**，此16进制数是字符串***SMAP***的ASCLL码。主要用于BIOS返回的ARDS写入`ES:DI`指向的内存后，用此签名校验其中信息。



返回**ARDS**后各个寄存器的信息：

1. **CF**：为0表示调用中断未出错，为1表示调用中断出错。主要起到一个标志位的作用；
2. **EAX**：存放签名字符串***SMAP***的ASCLL码；
3. **ES:DI**：ARDS缓冲区地址，与输入值相同。返回时其指向的内存已经填充了返回信息；
4. **ECX**：BIOS写入到ES:DI所指向的ARDS结构中的字节数；
5. **EBX**：下一个ARDS的位置。每次中断返回后，BIOS自动更新此寄存器的值。



综上我们执行中断获取内存信息的方法为：

1. **设置参数**，**更新**上述对应的寄存器的值；
2. **调用中断**，便会**执行对应的子功能**；
3. **查看返回的寄存器中的信息**。如果CF位为0，表示我们调用中断成功，且说明返回存储内存信息的ARDS已经被写入到了ES:DI指向的内存区域；
4. **找到对应的ARDS**，观察内存信息。



## 三 . 由linux联想至UCORE

上述我们对**linux**中如何获取可用物理内存范围进行了介绍，于是我们联想到其也可以运用到**ucore**当中。

我们在**ucore**中也可以设置相应的中断处理函数，并结合opensbi已经给我们提供的获取物理内存范围的接口，完全也可以设置出一个和**linux**的中断0x15的子功能0xe820类似的处理机制。即使用与上述一样的寄存器来记录相应参数，在`trap.c`的相应异常处理函数里面编写使用opensbi接口的函数，然后加之我们实现了页面分配机制以及任意内存大小的分配，为每次的ARDS存放寻找20字节的空间并不是难事。其分配的地址我们可以轻松计算并且存入到EBX寄存器中，每次的更新在异常处理函数中也可以完成。

综上，我们由**linux**的中断0x15子功能0xe820联想到了**ucore**中可用物理内存范围的探测方案，最终这个方案实现的效率已经难度都在合理范围之内。

