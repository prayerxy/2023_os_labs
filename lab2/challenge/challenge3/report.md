# lab2 Challenge3

**扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）**

> - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？

## 一 . 解决方法

如果OS无法提前知道当前硬件的可用物理内存范围，那么可以从以下角度去思考解决方案：

1. **操作系统自行探测内存**。操作系统自身可以通过运行一段特殊的代码或使用特殊的工具，以此来达到检测可用物理内存范围的目的。例如：
   - **迭代分配物理内存**。操作系统从起始地址开始一直向后分配内存，如果分配成功，则将其加入到可用物理内存范围中；如果分配失败，则说明已经到达物理内存上限。当达到物理内存上限后，逐步缩小分配的内存大小，最后便能确定可用物理内存范围；
   - **系统启动时进行内存探测**。操作系统在启动之前会有**bootloader**程序和预处理程序执行，这些程序的执行会对物理内存进行访问，操作系统可以通过这些程序对物理内存进行范围的大致探测；
   - **使用Opensbi固件接口**。Opensbi中拥有获取物理内存范围信息的接口`platform_memory_region`，此接口可以通过调用`platform.memory_region`函数来访问。最后会返回一个包含物理内存范围信息的结构体数组，每个元素对应**一个物理内存区域**的**起始地址**和**大小**。操作系统通过解析这些信息最终便可以成功获取可用的物理内存范围；
   - **使用系统管理工具**。操作系统提供的一些系统管理工具，可以显示当前系统的内存使用情况，包括可用内存和已用内存的数量。通过分析可用内存和已用内存便可以分析出可用物理内存范围。
2. **与硬件交互**。操作系统通过内存驱动管理程序来与硬件进行交互，从而可以读取硬件内存条上的信息，通过分析这些信息也可以对可用物理内存范围进行获取；

## 二  . linux中获取可用物理内存范围的方法

> linux中获取内存容量的方法有很多，共性是调用**BIOS中断的0x15**实现的，分别是**0x15**的三个子功能，子功能号存放在寄存器**EAX**或者**AX**中。BIOS中断可以返回已安装的硬件信息，它获取硬件信息也需要依靠硬件提供的接口。每次中断发生后，通过连续调用硬件的API便可以获取足够的内存信息。

---



**中断0x15的三个子功能分别为：**

1. **子功能0xe820；**
2. **子功能0xe801；**
3. **子功能0x88；**

这三个子功能中从**0xe820**到**0x88**能够查询的物理内存范围越来越小，功能越来越弱。linux中对三个子功能的调用是安装功能从强到弱的顺序来调用的，当一种子功能查询失败时才会依次调用下一种子功能。

下面我们对功能最强的中断0x15的子功能0xe820进行介绍。

---



### 对中断0x15的子功能0xe820的介绍：

此子功能返回的内存信息较丰富，包含多个属性字段，并且由地址范围描述符**(ARDS)**来组织这些数据。地址范围描述符结构如下：

| 字节偏移量 | 属性名称     | 描述             |
| ---------- | ------------ | ---------------- |
| 0          | BaseAddrLow  | 基地址的低32位   |
| 4          | BaseAddrHigh | 基地址的高32位   |
| 8          | LengthLow    | 内存长度的低32位 |
| 12         | LengthHigh   | 内存长度的高32位 |
| 16         | Type         | 本段内存的类型   |

此结构中五个属性字段全为4个字节大小，一共占20个字节大小。每次执行这个中断就会返回这样一个**ARDS**。**Type**字段为1表示这段内存可以被操作系统使用，为2则表示内存使用中或者被系统保留，操作系统不可以用此内存。

显然，我们根据Type字段以及基地址和内存长度便确定出了一片物理内存区域，并且还可以知道其可用不可用。



**BIOS中断是一段函数例程**，调用BIOS中断便需要**设置参数**，并将参数保存在寄存器中，对于BIOS中断0x15的0xe820来说，它所需要的参数及保存的寄存器如下：

1. **EAX**：存放子功能号，即**0xe820**；
2. **EBX**：ARDS后续值，主要作业是告诉中断下一次调用时返回哪个**ARDS**，第一次置**0**，后面不再需要关注；
3. **ES:DI**：ARDS缓冲区。每次中断后返回的**ARDS**写入此寄存器指向的内存；
4. **ECX**：ARDS结构的字节大小，即**20**；
5. **EDX**： 固定为签名，标记为**0x534d4150**，此16进制数是字符串***SMAP***的ASCLL码。主要用于BIOS返回的ARDS写入`ES:DI`指向的内存后，用此签名校验其中信息。



返回**ARDS**后各个寄存器的信息：

1. **CF**：为0表示调用中断未出错，为1表示调用中断出错。主要起到一个标志位的作用；
2. **EAX**：存放签名字符串***SMAP***的ASCLL码；
3. **ES:DI**：ARDS缓冲区地址，与输入值相同。返回时其指向的内存已经填充了返回信息；
4. **ECX**：BIOS写入到ES:DI所指向的ARDS结构中的字节数；
5. **EBX**：下一个ARDS的位置。每次中断返回后，BIOS自动更新此寄存器的值。



综上我们执行中断获取内存信息的方法为：

1. **设置参数**，**更新**上述对应的寄存器的值；
2. **调用中断**，便会**执行对应的子功能**；
3. **查看返回的寄存器中的信息**。如果CF位为0，表示我们调用中断成功，且说明返回存储内存信息的ARDS已经被写入到了ES:DI指向的内存区域；
4. **找到对应的ARDS**，观察内存信息。



## 三 . 由linux联想至UCORE

上述我们对**linux**中如何获取可用物理内存范围进行了介绍，于是我们联想到其也可以运用到**ucore**当中。

我们在ucore中的设计主要基于以下思路：

1. 设置相应中断处理函数。我们在想要获取当前可用物理内存范围时，触发一个中断，然后编写相应的中断处理函数。这个中断处理函数会处理一个此中断，类似于我们上述**linux**的中断**0x15**的子功能**0xe820**；
2. 在中断处理函数中设置参数给寄存器。类似于上述**linux**的中断**0x15**的子功能**0xe820**的存储参数进入寄存器，我们在中断处理函数中首先需要设置参数，将其保存在寄存器中。以此便保证了我们后续调用相应**opensbi**提供的获取物理内存范围信息的接口函数后能够获得正确的物理内存范围信息；
3. 在中断处理函数中编写代码来调用**opensbi**提供的获取物理内存范围信息的接口函数，以此来获取相应的物理内存范围信息。并将其返回信息保存在寄存器中，具体可以涉及一个标志位(说明获取信息是否成功)以及获取物理内存范围的起始地址和长度，这些与linux的中断**0x15**的子功能**0xe820**类似；
4. 使用我们获取的物理内存范围信息初始化内存管理器，以此可以实现页的分配机制以及任意内存大小的分配；
5. 提供API。通过提供API，我们可以实现与硬件交互，更加方便对opensbi提供的接口的访问；

综上，我们由**linux**的中断**0x15**子功能**0xe820**联想到了**ucore**中可用物理内存范围的探测方案，最终这个方案实现的效率已经难度都在合理范围之内。

