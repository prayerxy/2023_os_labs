# Lab1 report

## [练习1]

**练习1：理解内核启动中的程序入口操作**

> 阅读 `kern/init/entry.S`内容代码，结合操作系统内核启动流程，说明指令 `la sp, bootstacktop` 完成了什么操作，目的是什么？ `tail kern_init` 完成了什么操作，目的是什么？

---

`kern/init/entry.S`的源代码为:

```assembly
# kern/init/entry.S
#include <mmu.h>
#include <memlayout.h>

# 从这里开始.text 这个section, "ax" 和 %progbits描述这个section的特征

    .section .text,"ax",%progbits   #标记下面的代码为可执行代码段
    .globl kern_entry    #定义全局标识符，内核入口点
kern_entry: 
    la sp, bootstacktop  #la,load address，即将返回地址保存在sp寄存器中
    tail kern_init   #tail是tail call的缩写是RISC-V的一条伪指令，相当于函数调用

.section .data
    # .align 2^12
    .align PGSHIFT #按照2^PGSHIFT进行地址对齐
    .global bootstack #内核栈
bootstack:
    .space KSTACKSIZE #留出KSTACKSIZE这么多个字节的内存
    .global bootstacktop #之后内核栈将要从高地址向低地址增长, 初始时的内核栈为空
bootstacktop:
```

-  la sp, bootstacktop

bootstacktop指向的是分配的内核栈bootstack的栈顶，执行`la sp, bootstacktop`后sp指向了内核栈的栈顶。

这个指令的作用是将**栈指针sp**(stack pointer 即'sp'寄存器)设置为'**bookstacktop**'的地址。

栈指针用于管理函数调用时的栈帧，设置栈指针的目的是为了初始化内核的栈，便于后续的代码可以在内核栈上执行

- tail kern_init

`tail kern_init`是将pc跳转到`kern_init`函数的位置，将控制权转移给'kern_init'函数，并且以尾调用的方式执行该函数。使用尾调用的目的是保证函数调用结束后，不需要返回到原来函数的调用点。

同时kern_init函数为操作系统内核的初始化函数，负责初始化操作系统。

这样做**一方面**可以简化过程，*避免了栈帧的保存*，优化了函数的调用方式；**另一方面**还可以使程序*真正进入操作系统内核*，进一步地逐步执行程序，完成内核初始化的一系列操作。

---

## [练习2]

**练习2：完善中断处理（需要编程）**

> 请编程完善`trap.c`中的中断处理函数trap，在对时钟中断进行处理的部分填写`kern/trap/trap.c`函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用`print_ticks`子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的`shut_down()`函数关机。简要说明实现过程和定时器中断处理的流程。

---

### 1.关于clock.c的分析

```c
volatile size_t ticks;
static uint64_t timebase = 100000;
void clock_init(void) {
    // sie这个CSR可以单独使能/禁用某个来源的中断。默认时钟中断是关闭的
    //所以调用下面的函数使得时钟中断
    set_csr(sie, MIP_STIP);
    // divided by 500 when using Spike(2MHz)
    // divided by 100 when using QEMU(10MHz)
    // timebase = sbi_timebase() / 500;
    clock_set_next_event();

    // initialize time counter 'ticks' to zero
    ticks = 0;

    cprintf("++ setup timer interrupts\n");
}
//设置时钟中断：timer的数值变为当前时间 + timebase 后，触发一次时钟中断
//对于QEMU, timer增加1，过去了10^-7 s， 也就是100ns
//这里的timebase是指的时钟周期数。 timebase个时钟周期是10ms 也就是过10ms再触发一次
void clock_set_next_event(void) { sbi_set_timer(get_cycles() + timebase); }
```

1. 针对clock_set_next_event函数，有:

   - sbi_set_timer()是OpenSBI提供的接口，可以传入一个时刻。

   - get_cycles() 函数用于获取当前的 CPU 时钟周期数，这个值表示了从某一起始点到当前时刻的时钟周期数。这个值通常被用来度量程序的执行时间或者进行时间管理。

   - timebase 是一个常量，表示了一个时间单位内的时钟周期数。当前cpu一个时钟周期是10^-7s，然后timebase个时钟周期是10ms，也就是10^-2s，那么下次触发时间是当前时间后10ms。

2. 针对clock_init函数，有:

   - set_csr(sie,MIP_STIP)，set_csr 是一个用于设置 Control and Status Registers (CSR) 的宏，sie 是其中一个 CSR 的名称，它代表 "Supervisor Interrupt Enable"，用于控制处理器是否允许特定类型的中断，MIP_STIP 是一个宏，代表着 "Machine Timer Interrupt Pending"，它用于指示时钟中断是否待处理。因此，set_csr 用于将 MIP_STIP 对应的位设置为 1，即允许处理器在发生定时器中断时触发中断处理程序。
   - clock_set_next_event()，在函数其中调用此函数，设置10ms后的下一次中断。
   - 初始化ticks为0，此计数器的作用是记录中断的次数
   - 在屏幕上打印一行字符串.
   - 10ms后开始时钟中断。

---

### 2.关于中断处理的内部逻辑梳理

```c
trap.c:
struct trapframe {
    struct pushregs gpr;
    uintptr_t status;
    uintptr_t epc;
    uintptr_t badvaddr;
    uintptr_t cause;
};

trapentry.S:
    csrr s4, scause

    STORE s0, 2*REGBYTES(sp)
    STORE s1, 32*REGBYTES(sp)
    STORE s2, 33*REGBYTES(sp)
    STORE s3, 34*REGBYTES(sp)
    STORE s4, 35*REGBYTES(sp)
        
trap.c:
static inline void trap_dispatch(struct trapframe *tf) {
    if ((intptr_t)tf->cause < 0) {
        // interrupts
        interrupt_handler(tf);
    } else {
        // exceptions
        exception_handler(tf); 
    }
}
#define IRQ_S_TIMER  5
void interrupt_handler(struct trapframe *tf) {
    intptr_t cause = (tf->cause << 1) >> 1;
    switch (cause) {
        ...
        case IRQ_S_TIMER:
            ...
    }
}
```

在上面我截取了部分代码分析。

在触发中断后，首先会跳转至trapentry.S，开始保存当前执行流的上下文（即32个通用寄存器，加上4个特殊寄存器），在这里重点提出一个寄存器`scause`，它是CSR中的一个寄存器，作用是记录中断发生的原因。

之后通过函数调用，转换为trap.c的中断处理函数trap()的上下文，而之前上下文的寄存器值都会赋值给结构体trapframe，所以trapframe->cause的值，等于CSR中scause的值。由于中断时，scause寄存器会记录中断发生的原因，因此进入trap.c时会根据中断类型跳入interrupt_handler与exception_handler两个不同的函数处理中断。

在此练习中，我们是处理时钟中断，因此根据cause值会进入interrupt_handler函数中。

而最后在interrupt_handler函数中，我们可以发现，这里switch的条件式的值同样是cause，最后会进入IRQ_S_TIMER下的语句进行运行。

---

### 3.实现trap.c的编写

```c
#define TICK_NUM 100
volatile size_t num=0;//计数器的定义
void interrupt_handler(struct trapframe *tf) {
    intptr_t cause = (tf->cause << 1) >> 1;
    switch (cause) {
        ...
        case IRQ_S_TIMER:
            //处理计时器的相关中断
            // "All bits besides SSIP and USIP in the sip register are
            // read-only." -- privileged spec1.9.1, 4.1.4, p59
            // In fact, Call sbi_set_timer will clear STIP, or you can clear it
            // directly.
            // cprintf("Supervisor timer interrupt\n");
             /* LAB1 EXERCISE2   2113665+2113663:  */
            /*(1)设置下次时钟中断- clock_set_next_event()
             *(2)计数器（ticks）加一
             *(3)当计数器加到100的时候，我们会输出一个`100ticks`表示我们触发了100次时钟中断，同时打印次数（num）加一
            * (4)判断打印次数，当打印次数为10时，调用<sbi.h>中的关机函数关机
            */
            clock_set_next_event();
            ticks++;
            if(ticks%TICK_NUM==0){
                print_ticks();
                num++; //记录打印的次数
            }
            if(num==10){
                sbi_shutdown();//采用关机函数
            }
            break;
        ...
        default:
            print_trapframe(tf);
            break;
    }
}
```

在1、2的基础上，我们对时钟中断的内部逻辑十分清楚了，下面介绍trap.c的编写思路。

`IRQ_S_TIMER`用于表示 RISC-V 架构中的时钟中断。因此，本段补充代码的核心部分便是在`case IRQ_S_TIMER`部分，我们的实现思路主要如下：

- 设置下一次时钟中断(由`clock_set_next_event`函数实现），这样首先保证了下一次时钟中断在指定的10ms后触发。在这里必须要设置下一次时钟中断：因为在一次时间中断结束后会恢复上下文，返回原来中断的位置，而我们要触发有规律的时间中断，因此要在这里设置下一次触发。
- 计数器加1，获取现在的计数总次数；
- 进行条件判断，`ticks`是否已达到100，由**ticks%TICK_NUM==0**判断。如果条件成立，则将打印次数(`num`)加1；
- 对num条件判断，如果num==10成立，则调用`sbi.h`中的`sbi_shutdown`函数进行关机。

---

### 4.对init.c的分析

定时器中断处理流程：`kern/init/init.c`中的`kern_init`函数源代码如下：

```c
int kern_init(void) {
    extern char edata[], end[];
    memset(edata, 0, end - edata);

    cons_init();  // init the console

    const char *message = "(THU.CST) os is loading ...\n";
    cprintf("%s\n\n", message);

    print_kerninfo();

    // grade_backtrace();

    idt_init();  // init interrupt descriptor table
    // rdtime in mbare mode crashes
    clock_init();  // init clock interrupt
    intr_enable();  // enable irq interrupt
    while (1)
        ;
}
```

在进行定时器时钟中断处理时，上述函数主要分为了以下步骤：

1. 初始化中断，此步骤由`idt_init`实现。

  ```c
  void idt_init(void) {
      extern void __alltraps(void);
      /* Set sscratch register to 0, indicating to exception vector that we are
       * presently executing in the kernel */
      write_csr(sscratch, 0);
      /* Set the exception vector address */
      write_csr(stvec, &__alltraps);
  }
  ```

  此函数的作用是初始化中断描述符表，中断描述符表是用于处理各种异常和中断的重要数据结构。

  - extern void alltraps(void)：声明了一个名为alltraps 的外部函数，它是一个包含所有中断和异常处理程序的汇编代码文件的入口点，在里面将设置中断描述符表的地址。
  - write_csr(sscratch, 0) ：将 sscratch 寄存器的值设置为 0。sscratch 寄存器通常用于指示当前是否在内核模式下执行。设置为 0 表示在内核模式下执行。
  - write_csr(stvec, &alltraps) ：将 stvec 寄存器的值设置为 &alltraps，即中断描述符表的地址。stvec 寄存器是一个控制寄存器，用于指定异常处理程序的地址。设置为 &alltraps 后，当系统发生异常或中断时，处理程序将跳转到trapentry.S中的alltraps 函数的入口点，进而进入中断处理流程。

2. 初始化时钟中断，此步骤由`clock_init`实现。

  ```c
  void clock_init(void) {
      // enable timer interrupt in sie
      set_csr(sie, MIP_STIP);
      // divided by 500 when using Spike(2MHz)
      // divided by 100 when using QEMU(10MHz)
      // timebase = sbi_timebase() / 500;
      clock_set_next_event();
  
      // initialize time counter 'ticks' to zero
      ticks = 0;
  
      cprintf("++ setup timer interrupts\n");
  }
  
  void clock_set_next_event(void) { sbi_set_timer(get_cycles() + timebase); }
  ```

  > 此函数设置了下一次的时钟中断产生时间，并且初始化了计数器`ticks`（ticks置0），最终打印启动时钟中断的提示信息。

3. 设置中断使能位，此步骤由`intr_enable`实现。

  ```c
  #include <intr.h>
  #include <riscv.h>
  
  /* intr_enable - enable irq interrupt */
  void intr_enable(void) { set_csr(sstatus, SSTATUS_SIE); }
  
  /* intr_disable - disable irq interrupt */
  void intr_disable(void) { clear_csr(sstatus, SSTATUS_SIE); }
  ```

  - sstatus 表示 RISC-V 处理器状态寄存器，其中包含了多个控制处理器状态的位。
  - SSTATUS_SIE 是 sstatus 中用于表示全局中断使能的位。设置为 1 表示允许中断，清零表示禁用中断。

  调用`intr_enable`函数设置了sstatus的SIE位，使其能够接受中断并进行处理。这也就保证了处理器能够接受用户模式的中断请求并进行处理，时钟中断的处理有了保障。

4. 进入`while`循环，保证每次的定时器时钟中断稳定触发。

  每次在`while`循环中一旦触发时钟中断便进入中断处理程序，在中断处理程序中进入到对时钟中断的处理部分。即`interrupt_handler`函数中的`case IRQ_S_TIMER` 部分。

  紧接着结合我们对此部分的代码设计，先设置下一次时钟中断，再引入条件判断，最终便可以在打印完**10**行**“100 ticks”**后调用`sbi_shutdown`函数关机。

**综上，便是完整的定时器时钟中断处理流程。**

---

### 5.程序的正确性验证

<img src="1.png" style="zoom: 80%;" />

如上图所示，成功完成要求。在打印10次`100 ticks`后关机。

---

## 扩展练习 Challenge1：描述与理解中断流程

> 描述`ucore`中处理中断异常的流程（从异常的产生开始），其中`mov a0，sp`的目的是什么？`SAVE_ALL`中寄存器保存在栈中的位置是什么确定的？对于任何中断，`__alltraps` 中都需要保存所有寄存器吗？请说明理由。

---

### 1.处理中断的流程

> 中断分类为：异常、陷入、外部中断(时钟、I/O设备等)

其中异常与陷入都是CPU在执行指令中遇到的，而外部中断是CPU的执行过程被外设发来的信号所打断。

**处理中断异常的流程：**

```assembly
__alltraps:
    SAVE_ALL

    move  a0, sp
    jal trap
    # sp should be the same as before "jal trap"

    .globl __trapret
__trapret:
    RESTORE_ALL
    # return from supervisor call
    sret
```

- 当触发中断进入`S`态进行处理时，硬件自动将异常信息自动设置给与`CSR`相关的寄存器(`sepc`、`scause`等)。其中`sepc`记录了触发中断的那条指令的地址，而`scause`会记录中断产生的原因，还会记录此中断是否为一个外部中断。
- 触发中断后，处理程序将跳转到`trapentry.S`中的`alltraps `函数的入口点，进而进入中断处理流程。

1. 执行定义的`SAVE_ALL`代码，即开始保存上下文。在这里保存的方式是将32个普通寄存器与4个特殊的CSR寄存器(`sstatus`，`sepc`， `sbadaddr`，`scause`），保存到一个栈中。

2. 进入`trap`函数。首先，在上面保存的寄存器将作为参数，赋值给trap里面的一个结构体trapframe。在这里根据`tf->cause`，把中断处理和异常处理的工作分发给`interrupt_handler()`，`exception_handler()`。`interrupt_handler`处理外部的中断，而`exception_handler`处理异常或陷入。这两个函数再根据中断或异常的原因的不同类型(`scause`的数值)来进行不同的处理，具体的由switch语句跳转至不同的处理函数。

  - 其中异常处理函数中，必须会将保存的sepc寄存器的值进行更新，使其指向下一条指令的地址。否则会使**程序一直进行异常处理，陷入死循环**。
  - 而对于外部的中断，不用更新sepc寄存器的值，在中断处理程序执行完后，CPU会自动返回到中断点之后的指令继续执行。

  总结：处理中断的情况下不需要手动更新 epc，因为中断返回后会自动回到原来的程序。而处理异常的情况下，手动更新 epc 是为了将程序跳转到下一条指令，以便继续执行或者跳过引起异常的指令。

3. 执行定义的`RESTORE_ALL`代码恢复上下文。这里主要是将sp栈的各个值，恢复至特殊寄存器CSR与普通寄存器中，这样就让各个寄存器恢复至中断之前的值。不过对于异常来说，sepc与中断之前的值不一样，在异常的过程中sepc会指向下一条指令，避免程序继续异常处理。

### 2.mov a0,sp的目的

`mov a0，sp`是将`sp`栈指针的值赋值给`a0`。而最终`a0`的值是赋值给了`trap`函数的参数，所以其最终是将`sp`栈指针的指向地址赋值给了`trap`参数结构体指针。

观察保存上下文的代码与`trapframe`结构体的代码：

```c
    csrw sscratch, sp      
    addi sp, sp, -36 * REGBYTES    
    STORE x0, 0*REGBYTES(sp)
    STORE x1, 1*REGBYTES(sp)
    STORE x3, 3*REGBYTES(sp)
    STORE x4, 4*REGBYTES(sp)
    STORE x5, 5*REGBYTES(sp)
    STORE x6, 6*REGBYTES(sp)
    STORE x7, 7*REGBYTES(sp)
    STORE x8, 8*REGBYTES(sp)
    STORE x9, 9*REGBYTES(sp)
    STORE x10, 10*REGBYTES(sp)
    STORE x11, 11*REGBYTES(sp)
    STORE x12, 12*REGBYTES(sp)
    STORE x13, 13*REGBYTES(sp)
    STORE x14, 14*REGBYTES(sp)
    STORE x15, 15*REGBYTES(sp)
    STORE x16, 16*REGBYTES(sp)
    STORE x17, 17*REGBYTES(sp)
    STORE x18, 18*REGBYTES(sp)
    STORE x19, 19*REGBYTES(sp)
    STORE x20, 20*REGBYTES(sp)
    STORE x21, 21*REGBYTES(sp)
    STORE x22, 22*REGBYTES(sp)
    STORE x23, 23*REGBYTES(sp)
    STORE x24, 24*REGBYTES(sp)
    STORE x25, 25*REGBYTES(sp)
    STORE x26, 26*REGBYTES(sp)
    STORE x27, 27*REGBYTES(sp)
    STORE x28, 28*REGBYTES(sp)
    STORE x29, 29*REGBYTES(sp)
    STORE x30, 30*REGBYTES(sp)
    STORE x31, 31*REGBYTES(sp)

    csrrw s0, sscratch, x0
    csrr s1, sstatus
    csrr s2, sepc
    csrr s3, sbadaddr
    csrr s4, scause

    STORE s0, 2*REGBYTES(sp)
    STORE s1, 32*REGBYTES(sp)
    STORE s2, 33*REGBYTES(sp)
    STORE s3, 34*REGBYTES(sp)
    STORE s4, 35*REGBYTES(sp)
```



```c
struct pushregs {        //32个通用寄存器
    uintptr_t zero;  // Hard-wired zero
    uintptr_t ra;    // Return address
    uintptr_t sp;    // Stack pointer
    uintptr_t gp;    // Global pointer
    uintptr_t tp;    // Thread pointer
    uintptr_t t0;    // Temporary
    uintptr_t t1;    // Temporary
    uintptr_t t2;    // Temporary
    uintptr_t s0;    // Saved register/frame pointer
    uintptr_t s1;    // Saved register
    uintptr_t a0;    // Function argument/return value
    uintptr_t a1;    // Function argument/return value
    uintptr_t a2;    // Function argument
    uintptr_t a3;    // Function argument
    uintptr_t a4;    // Function argument
    uintptr_t a5;    // Function argument
    uintptr_t a6;    // Function argument
    uintptr_t a7;    // Function argument
    uintptr_t s2;    // Saved register
    uintptr_t s3;    // Saved register
    uintptr_t s4;    // Saved register
    uintptr_t s5;    // Saved register
    uintptr_t s6;    // Saved register
    uintptr_t s7;    // Saved register
    uintptr_t s8;    // Saved register
    uintptr_t s9;    // Saved register
    uintptr_t s10;   // Saved register
    uintptr_t s11;   // Saved register
    uintptr_t t3;    // Temporary
    uintptr_t t4;    // Temporary
    uintptr_t t5;    // Temporary
    uintptr_t t6;    // Temporary
};

struct trapframe {
    struct pushregs gpr;
	// 4个和中断相关的csr
    uintptr_t status;
    uintptr_t epc;
    uintptr_t badvaddr;
    uintptr_t cause;
};

```



可见`sp`所指向的栈空间大小为36个寄存器大小，且里面保存的寄存器内存布局方式和`trapframe`相关寄存器的布局方式完全一样。这说明此语句的作用是让保存上下文的栈sp的值赋给a0，而a0又是trap()的参数，它让被保存的寄存器的值，赋给trapframe结构体

这样便可以使中断异常处理时得到之前保存上下文的寄存器的值，可以在其中处理进行操作，比如需要scause的值来判断中断的类型。最终可以简化恢复上下文过程，还保证了与CSR相关寄存器的信息的及时更新，比如异常的sepc要进行更新。

### 3.save_all中寄存器保存在栈中的位置

`SAVE_ALL`中寄存器保存在栈中的位置是`trapframe`的结构确定的。trapframe中的寄存器的内存布局是什么样的，就应该保证`SAVE_ALL`中寄存器保存在栈中的位置与其一样。

因此寄存器保存在一个sp为栈指针的栈时，相关寄存器的顺序是固定的，而这些寄存器所占字节数也是固定的，因此偏移量也是固定的，所以save_all中寄存器保存在栈中的位置是由trapframe的结构确定的。这样才能使后续调用trap函数时直接对保存上下文的栈空间正确操作。

### 4.关于__alltraps

- sbadaddr（Supervisor Bad Address）：在某些异常中保存了引发异常的内存地址。它在异常处理中可能用于记录异常相关的地址信息，而在外部中断中没有被使用到

1. 相应的对于外部中断而言，`__alltraps` 中不需要保存sbadaddr寄存器的值。
2. 在`__alltraps` 中只需要保存32个通用的寄存器，与4个与中断机制有关的CSRs(ssstatus、sepc、sbadaddr、scause)，其余的一些CSRs不会被保存

---

## 扩展练习 Challenge2：理解上下文切换机制

> 在`trapentry.S`中汇编代码 `csrw sscratch, sp`和`csrrw s0, sscratch,  x0`实现了什么操作，目的是什么？`save all`里面保存了`stval` ，`scause`这些`csr`，而在`restore  all`里面却不还原它们？那这样`store`的意义何在呢？

---

```assembly
csrw sscratch, sp
csrrw s0, sscratch, x0
STORE s0, 2*REGBYTES(sp) #将旧的sp指针的值储存进栈中
```



- `csrw sscratch, sp`是将`sp`的指向地址赋值给`sscratch`寄存器

- `csrrw s0, sscratch, x0`将`sscratch`寄存器的值赋值给`s0`并将`sscratch`寄存器置0。目的是保存旧的栈指针至`s0`，通过`s0`来将旧的栈指针的值加载到保存上下文的区域即，最终实现旧的栈指针的保存。

**保存旧的sp值，是为了恢复上下文的时候，可以恢复sp的值至原来的位置，释放栈的空间**

`sava all`里面保存的四个与`csr`相关的寄存器，最终只恢复了`sstatus`和`sepc`寄存器，而`stval、scause`这两个寄存器并没有恢复。因为：

- `sret`指令涉及到`u`态和`s`态的转变，以及将`sepc`的值赋值给`pc`，且与中断异常的产生原因等方面无关；

- `scause`的存储内容与`u`态和`s`态的转变有关，`sepc`的值在异常处理过程中涉及更新。这两个寄存器的值都要恢复，否则`sret`指令执行会出现问题，因为sret的作用是将sepc赋值给pc。

- `stval`、`scause`中存储的是中断异常产生的原因，与`sret`的执行无关，仅仅在中断异常产生时起作用。并且每次异常中断产生之后硬件会自动更新，没有恢复的必要；

- 减少恢复的寄存器可以优化恢复上下文过程，节省资源与时间；

  

这样`store`的意义是优化恢复上下文的过程，在不影响程序运行的前提恢复了必要的上下文，节省了资源与时间。

---

## 扩展练习 Challenge3：完善异常中断

> 编程完善在触发一条非法指令异常 `mret`和`ebreak`，在  `kern/trap/trap.c`的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址，即“lllegal  instruction caught at 0x(地址)”，“ebreak caught at 0x（地址）”与“Exception  type:Illegal instruction"，“Exception type: breakpoint”。

---

### 1.补充异常指令位置：

```c
int kern_init(void) {
    extern char edata[], end[];
    memset(edata, 0, end - edata);
    cons_init();  // init the console
    const char *message = "(THU.CST) os is loading ...\n";
    cprintf("%s\n\n", message);
    print_kerninfo();
    // grade_backtrace();
    idt_init();  // init interrupt descriptor table
    asm volatile("mret");
    asm volatile("ebreak");
    // rdtime in mbare mode crashes
    clock_init();  // init clock interrupt
    intr_enable();  // enable irq interrupt
    while (1)
        ;
}
```

在上面的`kern_init`函数中以内联汇编的方式加入`mret`和`ebreak`两条指令。

- mret 是 RISC-V 架构中的一条指令，用于从机器模式返回到先前的特权级别。在 RISC-V 中，特权级别有不同的名称，通常包括机器模式（Machine Mode）、超级用户模式（Supervisor Mode）、用户模式（User Mode）等。mret 用于从机器模式切换回之前的特权级别。
- ebreak 指令主要用于软件调试。开发人员可以在程序中插入 ebreak 指令来中断程序执行，以检查程序状态和执行路径，以便查找错误或进行调试。


- __asm__ 是内联汇编的开始标记，表示接下来的内容是汇编指令。


- volatile 关键字告诉编译器不要对这个内联汇编做任何优化，确保它按照指定的顺序执行。

idt_init 通常用于初始化中断描述符表，而 intr_enable 用于启用中断。这两个操作通常在操作系统启动的早期进行，以确保中断机制正常工作。在这里采取先初始化中断描述表，然后触发mret与ebreak异常，触发时钟中断的顺序，最后启用中断。

---

### 2.补充异常处理源代码：

- 在 RISC-V 架构中，**ebreak 指令的大小通常是 2 字节（16 位）**。ebreak 指令用于生成一个断点异常，通常用于调试或异常处理。由于 RISC-V 支持指令集压缩，ebreak 是压缩指令之一，它的编码长度比标准的 32 位指令要短。这有助于节省存储空间和指令缓存的大小。
- 在 RISC-V 架构中，**mret 指令的大小通常是 4 字节（32 位）**。mret 指令用于从机器模式返回到先前的特权级别，通常是用户态或超级用户态。

```c
void exception_handler(struct trapframe *tf) {
    switch (tf->cause) {
        case CAUSE_MISALIGNED_FETCH:
            break;
        case CAUSE_FAULT_FETCH:
            break;
        case CAUSE_ILLEGAL_INSTRUCTION:
             // 非法指令异常处理
             /* LAB1 CHALLENGE3   2113663+2113665 :  */
            /*(1)输出指令异常类型（ Illegal instruction）
             *(2)输出异常指令地址
             *(3)更新 tf->epc寄存器
            */
            cprintf("Exception type:Illegal instruction\n");
            cprintf("Illegal instruction caught at 0x%08x\n",tf->epc);
            tf->epc+=4;
            break;
        case CAUSE_BREAKPOINT:
            //断点异常处理
            /* LAB1 CHALLLENGE3   2113663+2113665 :  */
            /*(1)输出指令异常类型（ breakpoint）
             *(2)输出异常指令地址
             *(3)更新 tf->epc寄存器
            */
            cprintf("Exception type:breakpoint\n");
            cprintf("ebreak caught at 0x%08x\n",tf->epc);
            tf->epc+=2;
            break;
        ...
        default:
            print_trapframe(tf);
            break;
    }
}
```

​	    我们由之前的总结分析可以知道，对于异常而言，我们需要手动的更新sepc的值，在这里我们会对tf的epc进行更新，指向下一条指令，这样在恢复上下文的时候sepc的值也会得到更新，那么pc的值也会得到更新，因此程序就可以继续运行，而不是在异常指令处卡死。

​		由上面的分析可得，mret的指令大小为4个字节，ebreak的指令大小为2个字节，那么相应的对于mret而言，tf->epc+=4；而对于ebreak而言，tf->epc+=2。

​		而这里%08x 是一个格式说明符，它告诉 cprintf 在这个位置插入一个无符号整数，并以十六进制格式显示，使用至少8个字符宽度，不足的地方用零填充。那么最后这条语句打印一条消息，指示 "ebreak" 异常发生的位置，其地址由 tf->epc 提供，并以十六进制格式显示。

---

### 3.成功性验证：

<img src="2.png" alt="2" style="zoom: 67%;" />



说明：

- `mret`指令的大小为==4个字节==，`ebreak`指令由于`Risc-v`指令集压缩大小变为==2个字节==，所以两者在更新`tf->epc`时一个是向后偏移四个字节，一个是偏移2个字节；
- 最后输出结果中首先处理了非法指令异常，然后又处理了断点异常，最后还处理了时钟中断。在输出10次`100 ticks`后关机成功。
