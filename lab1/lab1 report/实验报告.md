# Lab1 report

## [练习1]

**练习1：理解内核启动中的程序入口操作**

阅读 `kern/init/entry.S`内容代码，结合操作系统内核启动流程，说明指令 `la sp, bootstacktop` 完成了什么操作，目的是什么？ `tail kern_init` 完成了什么操作，目的是什么？

---

`kern/init/entry.S`的源代码为:

```
# kern/init/entry.S
#include <mmu.h>
#include <memlayout.h>

# The ,"ax",@progbits tells the assembler that the section is allocatable ("a"), executable ("x") and contains data ("@progbits").
# 从这里开始.text 这个section, "ax" 和 %progbits描述这个section的特征
# https://www.nongnu.org/avr-libc/user-manual/mem_sections.html
.section .text,"ax",%progbits 
    .globl kern_entry # 使得ld能够看到kern_entry这个符号所在的位置, globl和global同义
    # https://sourceware.org/binutils/docs/as/Global.html#Global
kern_entry: 
    la sp, bootstacktop 
    tail kern_init 
#开始data section
.section .data
    .align PGSHIFT #按照2^PGSHIFT进行地址对齐, 也就是对齐到下一页 PGSHIFT在 mmu.h定义
    .global bootstack #内核栈
bootstack:
    .space KSTACKSIZE #留出KSTACKSIZE这么多个字节的内存
    .global bootstacktop #之后内核栈将要从高地址向低地址增长, 初始时的内核栈为空
bootstacktop:
```

由源代码我们可以看出，bootstacktop指向的是分配的内核栈bootstack的栈顶，执行`la sp, bootstacktop`后sp指向了内核栈的栈顶。这样做的目的便是保证了接下来的程序可以在分配的内核栈上进行堆栈操作。

`tail kern_init`是将pc跳转到`kern_init`函数的位置，并且以==尾调用==的方式执行该函数。使用尾调用的目的是保证函数调用结束后==不需要返回到原来函数的调用点==。这样做**一方面**可以简化过程，==避免了栈帧的保存==，优化了函数的调用方式；**另一方面**还可以使程序==真正进入操作系统内核==，进一步地逐步执行程序，完成内核初始化的一系列操作。



## [练习2]

**练习2：完善中断处理（需要编程）**

请编程完善`trap.c`中的中断处理函数trap，在对时钟中断进行处理的部分填写`kern/trap/trap.c`函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用`print_ticks`子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的`shut_down()`函数关机。简要说明实现过程和定时器中断中断处理的流程。

---



```c
void interrupt_handler(struct trapframe *tf) {
    intptr_t cause = (tf->cause << 1) >> 1;
    switch (cause) {
        case IRQ_U_SOFT:
            cprintf("User software interrupt\n");
            break;
        case IRQ_S_SOFT:
            cprintf("Supervisor software interrupt\n");
            break;
        case IRQ_H_SOFT:
            cprintf("Hypervisor software interrupt\n");
            break;
        case IRQ_M_SOFT:
            cprintf("Machine software interrupt\n");
            break;
        case IRQ_U_TIMER:
            cprintf("User software interrupt\n");
            break;
        case IRQ_S_TIMER:
            // "All bits besides SSIP and USIP in the sip register are
            // read-only." -- privileged spec1.9.1, 4.1.4, p59
            // In fact, Call sbi_set_timer will clear STIP, or you can clear it
            // directly.
            // cprintf("Supervisor timer interrupt\n");
             /* LAB1 EXERCISE2   2113663 :  */
             clock_set_next_event();
			ticks++;
			if(ticks%100==0){
				print_ticks();
				num++;
			}
			if(num==10)
				sbi_shutdown();
            /*(1)设置下次时钟中断- clock_set_next_event()
             *(2)计数器（ticks）加一
             *(3)当计数器加到100的时候，我们会输出一个`100ticks`表示我们触发了100次时钟中断，同时打印次数（num）加一
            * (4)判断打印次数，当打印次数为10时，调用<sbi.h>中的关机函数关机
            */
			
            break;
        case IRQ_H_TIMER:
            cprintf("Hypervisor software interrupt\n");
            break;
        case IRQ_M_TIMER:
            cprintf("Machine software interrupt\n");
            break;
        case IRQ_U_EXT:
            cprintf("User software interrupt\n");
            break;
        case IRQ_S_EXT:
            cprintf("Supervisor external interrupt\n");
            break;
        case IRQ_H_EXT:
            cprintf("Hypervisor software interrupt\n");
            break;
        case IRQ_M_EXT:
            cprintf("Machine software interrupt\n");
            break;
        default:
            print_trapframe(tf);
            break;
    }
}
```

本段补充代码的核心部分便是在`case IRQ_S_TIMER`部分，我们的实现思路主要如下：

- 设置下一次时钟中断(由`clock_set_next_event`函数实现），这样首先保证了下一次时钟中断在指定的一秒后触发；
- 计数器加1，获取现在的计数总次数；
- 进行条件判断，`ticks`是否已达到100，由**ticks%100==0**判断。如果条件成立，则将打印次数(`num`)加1；
- 对num条件判断，如果num==10成立，则调用`sbi.h`中的`sbi_shutdown`函数进行关机。



定时器中断处理流程：

