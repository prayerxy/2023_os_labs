# Lab1 report

## [练习1]

**练习1：理解内核启动中的程序入口操作**

阅读 `kern/init/entry.S`内容代码，结合操作系统内核启动流程，说明指令 `la sp, bootstacktop` 完成了什么操作，目的是什么？ `tail kern_init` 完成了什么操作，目的是什么？

---

`kern/init/entry.S`的源代码为:

```
# kern/init/entry.S
#include <mmu.h>
#include <memlayout.h>

# The ,"ax",@progbits tells the assembler that the section is allocatable ("a"), executable ("x") and contains data ("@progbits").
# 从这里开始.text 这个section, "ax" 和 %progbits描述这个section的特征
# https://www.nongnu.org/avr-libc/user-manual/mem_sections.html
.section .text,"ax",%progbits 
    .globl kern_entry # 使得ld能够看到kern_entry这个符号所在的位置, globl和global同义
    # https://sourceware.org/binutils/docs/as/Global.html#Global
kern_entry: 
    la sp, bootstacktop 
    tail kern_init 
#开始data section
.section .data
    .align PGSHIFT #按照2^PGSHIFT进行地址对齐, 也就是对齐到下一页 PGSHIFT在 mmu.h定义
    .global bootstack #内核栈
bootstack:
    .space KSTACKSIZE #留出KSTACKSIZE这么多个字节的内存
    .global bootstacktop #之后内核栈将要从高地址向低地址增长, 初始时的内核栈为空
bootstacktop:
```

由源代码我们可以看出，bootstacktop指向的是分配的内核栈bootstack的栈顶，执行`la sp, bootstacktop`后sp指向了内核栈的栈顶。这样做的目的便是保证了接下来的程序可以在分配的内核栈上进行堆栈操作。

`tail kern_init`是将pc跳转到`kern_init`函数的位置，并且以==尾调用==的方式执行该函数。使用尾调用的目的是保证函数调用结束后==不需要返回到原来函数的调用点==。这样做**一方面**可以简化过程，==避免了栈帧的保存==，优化了函数的调用方式；**另一方面**还可以使程序==真正进入操作系统内核==，进一步地逐步执行程序，完成内核初始化的一系列操作。



## [练习2]

**练习2：完善中断处理（需要编程）**

请编程完善`trap.c`中的中断处理函数trap，在对时钟中断进行处理的部分填写`kern/trap/trap.c`函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用`print_ticks`子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的`shut_down()`函数关机。简要说明实现过程和定时器中断中断处理的流程。

---



```c
void interrupt_handler(struct trapframe *tf) {
    intptr_t cause = (tf->cause << 1) >> 1;
    switch (cause) {
        case IRQ_U_SOFT:
            cprintf("User software interrupt\n");
            break;
        case IRQ_S_SOFT:
            cprintf("Supervisor software interrupt\n");
            break;
        case IRQ_H_SOFT:
            cprintf("Hypervisor software interrupt\n");
            break;
        case IRQ_M_SOFT:
            cprintf("Machine software interrupt\n");
            break;
        case IRQ_U_TIMER:
            cprintf("User software interrupt\n");
            break;
        case IRQ_S_TIMER:
            // "All bits besides SSIP and USIP in the sip register are
            // read-only." -- privileged spec1.9.1, 4.1.4, p59
            // In fact, Call sbi_set_timer will clear STIP, or you can clear it
            // directly.
            // cprintf("Supervisor timer interrupt\n");
             /* LAB1 EXERCISE2   2113663 :  */
             clock_set_next_event();
			ticks++;
			if(ticks%100==0){
				print_ticks();
				num++;
			}
			if(num==10)
				sbi_shutdown();
            /*(1)设置下次时钟中断- clock_set_next_event()
             *(2)计数器（ticks）加一
             *(3)当计数器加到100的时候，我们会输出一个`100ticks`表示我们触发了100次时钟中断，同时打印次数（num）加一
            * (4)判断打印次数，当打印次数为10时，调用<sbi.h>中的关机函数关机
            */
			
            break;
        case IRQ_H_TIMER:
            cprintf("Hypervisor software interrupt\n");
            break;
        case IRQ_M_TIMER:
            cprintf("Machine software interrupt\n");
            break;
        case IRQ_U_EXT:
            cprintf("User software interrupt\n");
            break;
        case IRQ_S_EXT:
            cprintf("Supervisor external interrupt\n");
            break;
        case IRQ_H_EXT:
            cprintf("Hypervisor software interrupt\n");
            break;
        case IRQ_M_EXT:
            cprintf("Machine software interrupt\n");
            break;
        default:
            print_trapframe(tf);
            break;
    }
}
```

本段补充代码的核心部分便是在`case IRQ_S_TIMER`部分，我们的实现思路主要如下：

- 设置下一次时钟中断(由`clock_set_next_event`函数实现），这样首先保证了下一次时钟中断在指定的一秒后触发；
- 计数器加1，获取现在的计数总次数；
- 进行条件判断，`ticks`是否已达到100，由**ticks%100==0**判断。如果条件成立，则将打印次数(`num`)加1；
- 对num条件判断，如果num==10成立，则调用`sbi.h`中的`sbi_shutdown`函数进行关机。



定时器中断处理流程：`kern/init/init.c`中的`kern_init`函数源代码如下：

```c
int kern_init(void) {
    extern char edata[], end[];
    memset(edata, 0, end - edata);

    cons_init();  // init the console

    const char *message = "(THU.CST) os is loading ...\n";
    cprintf("%s\n\n", message);

    print_kerninfo();

    // grade_backtrace();

    idt_init();  // init interrupt descriptor table
    // rdtime in mbare mode crashes
    clock_init();  // init clock interrupt
    intr_enable();  // enable irq interrupt
    while (1)
        ;
}
```

在进行定时器时钟中断处理时，上述函数主要分为了以下步骤：

- 初始化中断，此步骤由`idt_init`实现。

  > 由于中断处理程序只有一个，便将`__alltraps`（中断处理程序入口）的地址写入`stvec`寄存器（存放中断处理程序入口地址），由`write_csr(stvec, &__alltraps)`实现；

  ```c
  void idt_init(void) {
      extern void __alltraps(void);
      /* Set sscratch register to 0, indicating to exception vector that we are
       * presently executing in the kernel */
      write_csr(sscratch, 0);
      /* Set the exception vector address */
      write_csr(stvec, &__alltraps);
  }
  ```

- 初始化时钟中断，此步骤由`clock_init`实现。

  ```c
  void clock_init(void) {
      // enable timer interrupt in sie
      set_csr(sie, MIP_STIP);
      // divided by 500 when using Spike(2MHz)
      // divided by 100 when using QEMU(10MHz)
      // timebase = sbi_timebase() / 500;
      clock_set_next_event();
  
      // initialize time counter 'ticks' to zero
      ticks = 0;
  
      cprintf("++ setup timer interrupts\n");
  }
  
  void clock_set_next_event(void) { sbi_set_timer(get_cycles() + timebase); }
  ```

  > 此函数设置了下一次的时钟中断产生时间，并且初始化了计数器`ticks`（ticks置0），最终打印启动时钟中断的提示信息。

- 设置中断使能位，此步骤由`intr_enable`实现。

  ```c
  #include <intr.h>
  #include <riscv.h>
  
  /* intr_enable - enable irq interrupt */
  void intr_enable(void) { set_csr(sstatus, SSTATUS_SIE); }
  
  /* intr_disable - disable irq interrupt */
  void intr_disable(void) { clear_csr(sstatus, SSTATUS_SIE); }
  ```

  调用`intr_enable`函数设置了sstatus的SIE位，使其能够接受中断并进行处理。这也就保证了处理器能够接受用户模式的中断请求并进行处理，时钟中断的处理有了保障。

- 进入`while`循环，保证每次的定时器时钟中断稳定触发。

  每次在`while`循环中一旦触发时钟中断便进入中断处理程序，在中断处理程序中进入到对时钟中断的处理部分。即`interrupt_handler`函数中的`case IRQ_S_TIMER` 部分。

  紧接着结合我们对此部分的代码设计，先设置下一次时钟中断，再引入条件判断，最终便可以在打印完**10**行**“100 ticks”**后调用`sbi_shutdown`函数关机。

**综上，便是完整的定时器时钟中断处理流程。**



## 扩展练习 Challenge1：描述与理解中断流程

描述`ucore`中处理中断异常的流程（从异常的产生开始），其中`mov a0，sp`的目的是什么？`SAVE_ALL`中寄存器保存在栈中的位置是什么确定的？对于任何中断，`__alltraps` 中都需要保存所有寄存器吗？请说明理由。

---



处理中断异常的流程：

- 当中断异常抛出产生开始后，硬件自动将异常信息自动设置给与`CSR`相关的寄存器；

- 进入到中断异常处理程序入口，保存上下文；

- 进入`trap`函数。把中断处理和异常处理的工作分发给`interrupt_handler()`，`exception_handler()`。这两个函数再根据中断或异常的原因的不同类型(`scause`的数值)来进行不同的处理。

  其中异常处理函数中==可能会将保存的sepc寄存器的值进行更新，使其指向下一条指令的地址==。否则会使**程序一直进行异常处理，陷入死循环**。

- 恢复上下文，将sepc寄存器的指向地址赋值给pc，继续执行接下来的程序。



`mov a0，sp`是将`sp`栈指针的值赋值给`a0`。而最终`a0`的值是赋值给了`trap`函数的参数，所以其最终是将`sp`栈指针的指向地址赋值给了`trap`参数结构体指针。

观察保存上下文的代码与`trapframe`结构体的代码：

```c
    csrw sscratch, sp      
    addi sp, sp, -36 * REGBYTES    
    STORE x0, 0*REGBYTES(sp)
    STORE x1, 1*REGBYTES(sp)
    STORE x3, 3*REGBYTES(sp)
    STORE x4, 4*REGBYTES(sp)
    STORE x5, 5*REGBYTES(sp)
    STORE x6, 6*REGBYTES(sp)
    STORE x7, 7*REGBYTES(sp)
    STORE x8, 8*REGBYTES(sp)
    STORE x9, 9*REGBYTES(sp)
    STORE x10, 10*REGBYTES(sp)
    STORE x11, 11*REGBYTES(sp)
    STORE x12, 12*REGBYTES(sp)
    STORE x13, 13*REGBYTES(sp)
    STORE x14, 14*REGBYTES(sp)
    STORE x15, 15*REGBYTES(sp)
    STORE x16, 16*REGBYTES(sp)
    STORE x17, 17*REGBYTES(sp)
    STORE x18, 18*REGBYTES(sp)
    STORE x19, 19*REGBYTES(sp)
    STORE x20, 20*REGBYTES(sp)
    STORE x21, 21*REGBYTES(sp)
    STORE x22, 22*REGBYTES(sp)
    STORE x23, 23*REGBYTES(sp)
    STORE x24, 24*REGBYTES(sp)
    STORE x25, 25*REGBYTES(sp)
    STORE x26, 26*REGBYTES(sp)
    STORE x27, 27*REGBYTES(sp)
    STORE x28, 28*REGBYTES(sp)
    STORE x29, 29*REGBYTES(sp)
    STORE x30, 30*REGBYTES(sp)
    STORE x31, 31*REGBYTES(sp)

    csrrw s0, sscratch, x0
    csrr s1, sstatus
    csrr s2, sepc
    csrr s3, sbadaddr
    csrr s4, scause

    STORE s0, 2*REGBYTES(sp)
    STORE s1, 32*REGBYTES(sp)
    STORE s2, 33*REGBYTES(sp)
    STORE s3, 34*REGBYTES(sp)
    STORE s4, 35*REGBYTES(sp)
```



```c
struct pushregs {        //32个通用寄存器
    uintptr_t zero;  // Hard-wired zero
    uintptr_t ra;    // Return address
    uintptr_t sp;    // Stack pointer
    uintptr_t gp;    // Global pointer
    uintptr_t tp;    // Thread pointer
    uintptr_t t0;    // Temporary
    uintptr_t t1;    // Temporary
    uintptr_t t2;    // Temporary
    uintptr_t s0;    // Saved register/frame pointer
    uintptr_t s1;    // Saved register
    uintptr_t a0;    // Function argument/return value
    uintptr_t a1;    // Function argument/return value
    uintptr_t a2;    // Function argument
    uintptr_t a3;    // Function argument
    uintptr_t a4;    // Function argument
    uintptr_t a5;    // Function argument
    uintptr_t a6;    // Function argument
    uintptr_t a7;    // Function argument
    uintptr_t s2;    // Saved register
    uintptr_t s3;    // Saved register
    uintptr_t s4;    // Saved register
    uintptr_t s5;    // Saved register
    uintptr_t s6;    // Saved register
    uintptr_t s7;    // Saved register
    uintptr_t s8;    // Saved register
    uintptr_t s9;    // Saved register
    uintptr_t s10;   // Saved register
    uintptr_t s11;   // Saved register
    uintptr_t t3;    // Temporary
    uintptr_t t4;    // Temporary
    uintptr_t t5;    // Temporary
    uintptr_t t6;    // Temporary
};

struct trapframe {
    struct pushregs gpr;
	// 4个和中断相关的csr
    uintptr_t status;
    uintptr_t epc;
    uintptr_t badvaddr;
    uintptr_t cause;
};

```

可见`sp`所指向的栈空间大小为36个寄存器大小，且里面保存的寄存器内存布局方式和`trapframe`相关寄存器的布局方式完全一样。这样便可以使中断异常处理时直接对保存的上下文中的与CSR相关的寄存器进行操作。最终可以简化恢复上下文过程，还保证了与CSR相关寄存器的信息的及时更新。



`SAVE_ALL`中寄存器保存在栈中的位置是有`trapframe`的结构确定的。trapframe中的寄存器的内存布局是什么样的，就应该保证`SAVE_ALL`中寄存器保存在栈中的位置与其一样。这样才能使后续调用trap函数时直接对保存上下文的栈空间正确操作。



`__alltraps` 中不需要保存所有寄存器。一般只需保存**32**个**通用寄存器**和**4**个与**中断异常处理**有关的寄存器。具体需要保存的寄存器可以根据中断处理程序的需求而有所不同，寄存器的保存也可以有所选择。



## 扩展练习 Challenge2：理解上下文切换机制

在`trapentry.S`中汇编代码 `csrw sscratch, sp`和`csrrw s0, sscratch,  x0`实现了什么操作，目的是什么？`save all`里面保存了`stval` ，`scause`这些`csr`，而在`restore  all`里面却不还原它们？那这样`store`的意义何在呢？

---

`csrw sscratch, sp`是将`sp`的指向地址赋值给`sscratch`寄存器，`csrrw s0, sscratch,  x0`将`sscratch`寄存器的值赋值给`s0`并将`sscratch`寄存器置0。目的是保存旧的栈指针至`s0`，通过`s0`来旧的栈指针的值加载到保存上下文的区域，最终实现旧的栈指针的保存。



`sava all`里面保存的四个与csr相关的寄存器，最终只恢复了`sstatus`和`sepc`寄存器，而`stval、scause`这两个寄存器并没有恢复。因为：

- `sret`指令涉及到`u`态和`s`态的转变，以及将`sepc`的值赋值给`pc`，且与中断异常的产生原因等方面无关；
- `scause`的存储内容与`u`态和`s`态的转变有关，`sepc`的值在异常处理过程中涉及更新。这两个寄存器的值都要恢复，否则`sret`指令执行会出现问题；
- stval、scause中存储的是中断异常产生的原因，与sret的执行无关。并且每次异常中断产生之后硬件会自动更新，没有恢复的必要；
- 减少恢复的寄存器可以优化恢复上下文过程，节省资源与时间；
